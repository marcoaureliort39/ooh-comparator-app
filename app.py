# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U1x1DxRsJ1WQQjkqUkQR4DkAmPc44OQ8
"""

import streamlit as st
import pandas as pd
import io
import re

# --- CONFIGURA√á√ïES GLOBAIS ---
# Coluna de ID √öNICO
ID_UNICO = 'CodigoPontoOohFiliado'
DELIMITADOR_CSV = ';'
st.set_page_config(page_title="Comparador de Bases OOH", layout="centered")


# --- FUN√á√ÉO DE COMPARA√á√ÉO CORE ---

def comparar_bases_ooh(df_antigo, df_novo, coluna_id_unica):
    """
    Compara as duas bases de dados (DataFrames), incluindo limpeza e filtro robustos.
    Retorna os DataFrames de Novas, Removidas e Alteradas.
    """

    # 1. Pr√©-processamento e padroniza√ß√£o da coluna ID
    if coluna_id_unica not in df_antigo.columns or coluna_id_unica not in df_novo.columns:
        st.error(f"üö® ERRO: A coluna de ID √öNICO ('{coluna_id_unica}') n√£o foi encontrada em um ou ambos os arquivos.")
        return None, None, None

    # Limpeza Robusta do ID: for√ßa string, preenche nulo, remove caracteres especiais.
    df_antigo[coluna_id_unica] = (
        df_antigo[coluna_id_unica].fillna('').astype(str)
        .str.strip().apply(lambda x: re.sub(r'[^a-zA-Z0-9-]', '', x))
    )
    df_novo[coluna_id_unica] = (
        df_novo[coluna_id_unica].fillna('').astype(str)
        .str.strip().apply(lambda x: re.sub(r'[^a-zA-Z0-9-]', '', x))
    )

    # 2. Identificar Pontos Novos e Removidos (Merge Completo)
    df_comparacao = pd.merge(
        df_antigo, df_novo,
        on=coluna_id_unica,
        how='outer',
        suffixes=('_Antigo', '_Novo'),
        indicator=True
    )

    # L√≥gica de Novos, Removidos e Alterados (inalterada)
    df_novos = df_comparacao[df_comparacao['_merge'] == 'right_only'].copy()
    colunas_novo = [col for col in df_novos.columns if '_Novo' in col or col == coluna_id_unica]
    df_novos = df_novos[colunas_novo]
    df_novos.columns = [col.replace('_Novo', '') for col in df_novos.columns]

    df_removidos = df_comparacao[df_comparacao['_merge'] == 'left_only'].copy()
    colunas_antigo = [col for col in df_removidos.columns if '_Antigo' in col or col == coluna_id_unica]
    df_removidos = df_removidos[colunas_antigo]
    df_removidos.columns = [col.replace('_Antigo', '') for col in df_removidos.columns]

    df_existentes = df_comparacao[df_comparacao['_merge'] == 'both'].drop(columns=['_merge'])
    colunas_a_comparar = [col for col in df_antigo.columns if col != coluna_id_unica]

    lista_alterados = []
    for index, row in df_existentes.iterrows():
        alterado_atributo = False
        registro_alteracao = {coluna_id_unica: row[coluna_id_unica]}

        for col in colunas_a_comparar:
            val_antigo = str(row.get(f'{col}_Antigo')).strip()
            val_novo = str(row.get(f'{col}_Novo')).strip()

            if val_antigo != val_novo and val_antigo.lower() != 'nan' and val_novo.lower() != 'nan':
                alterado_atributo = True
                registro_alteracao[f'{col} (ANTIGO)'] = val_antigo
                registro_alteracao[f'{col} (NOVO)'] = val_novo

        id_antigo_raw = str(row.get(f'{coluna_id_unica}_Antigo')).strip()
        id_novo_raw = str(row.get(f'{coluna_id_unica}_Novo')).strip()

        if alterado_atributo or id_antigo_raw != id_novo_raw:
            if id_antigo_raw != id_novo_raw:
                registro_alteracao[f'{coluna_id_unica} (ANTIGO)'] = id_antigo_raw
                registro_alteracao[f'{coluna_id_unica} (NOVO)'] = id_novo_raw
            lista_alterados.append(registro_alteracao)

    df_alterados = pd.DataFrame(lista_alterados)

    # 3. FILTRO FINAL: Remove falsos positivos de ID
    if not df_alterados.empty:
        colunas_atributo_alterado = [
            col for col in df_alterados.columns
            if col.endswith('ANTIGO)') and not col.startswith(coluna_id_unica)
        ]

        if colunas_atributo_alterado:
            df_alterados['HOUVE_ALTERACAO_ATRIBUTO'] = df_alterados[colunas_atributo_alterado].notna().any(axis=1)
            df_alterados_filtrado = df_alterados[df_alterados['HOUVE_ALTERACAO_ATRIBUTO']].drop(columns=['HOUVE_ALTERACAO_ATRIBUTO'])

            id_antigo_col = f'{coluna_id_unica} (ANTIGO)'
            id_novo_col = f'{coluna_id_unica} (NOVO)'
            df_alterados_filtrado = df_alterados_filtrado.drop(columns=[id_antigo_col, id_novo_col], errors='ignore')
        else:
            df_alterados_filtrado = pd.DataFrame()

        df_alterados = df_alterados_filtrado

    return df_novos, df_removidos, df_alterados


# --- FUN√á√ÉO DE GERA√á√ÉO DO EXCEL ---

@st.cache_data
def gerar_excel_bytes(df_novos, df_removidos, df_alterados):
    """Cria o arquivo Excel em mem√≥ria (bytes) para download."""
    output = io.BytesIO()

    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df_novos.to_excel(writer, sheet_name='1_PONTOS_NOVOS', index=False)
        df_removidos.to_excel(writer, sheet_name='2_PONTOS_REMOVIDOS', index=False)

        if not df_alterados.empty:
            cols_final = [ID_UNICO] + [col for col in df_alterados.columns if col != ID_UNICO]
            df_alterados[cols_final].to_excel(writer, sheet_name='3_PONTOS_ALTERADOS', index=False)
        else:
            pd.DataFrame({'INFO': ['Nenhuma altera√ß√£o de atributo detectada ap√≥s a limpeza de IDs.']}).to_excel(writer, sheet_name='3_PONTOS_ALTERADOS', index=False)

    return output.getvalue()


# --- INTERFACE STREAMLIT PRINCIPAL ---

st.title("üìä Comparador Autom√°tico de Bases OOH")
st.markdown("Carregue a base do m√™s passado e a base do m√™s atual para gerar um relat√≥rio de altera√ß√µes.")

col1, col2 = st.columns(2)

uploaded_file_antigo = col1.file_uploader(
    "1. Carregue a **Base Antiga** (M√™s Passado)",
    type=['csv'],
    accept_multiple_files=False,
    key='file_antigo'
)

uploaded_file_novo = col2.file_uploader(
    "2. Carregue a **Base Nova** (M√™s Atual)",
    type=['csv'],
    accept_multiple_files=False,
    key='file_novo'
)

if uploaded_file_antigo is not None and uploaded_file_novo is not None:

    st.markdown("---")
    st.info("‚úÖ Arquivos carregados. Processando...")

    try:
        # L√™ os arquivos usando o delimitador correto
        df_antigo = pd.read_csv(uploaded_file_antigo, sep=DELIMITADOR_CSV, dtype={ID_UNICO: str})
        df_novo = pd.read_csv(uploaded_file_novo, sep=DELIMITADOR_CSV, dtype={ID_UNICO: str})

        df_novos, df_removidos, df_alterados = comparar_bases_ooh(df_antigo, df_novo, ID_UNICO)

        if df_novos is None:
             st.stop()

        excel_data = gerar_excel_bytes(df_novos, df_removidos, df_alterados)

        st.success("üéâ Compara√ß√£o finalizada! Seu relat√≥rio est√° pronto.")

        st.write(f"| **Pontos Novos:** {len(df_novos)}")
        st.write(f"| **Pontos Removidos:** {len(df_removidos)}")
        st.write(f"| **Pontos Alterados:** {len(df_alterados)}")
        st.markdown("---")

        st.download_button(
            label="‚¨áÔ∏è Baixar Relat√≥rio_Comparacao_OOH.xlsx",
            data=excel_data,
            file_name="Relatorio_Comparacao_OOH.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            help="Clique para baixar o relat√≥rio completo."
        )

    except Exception as e:
        st.error(f"‚ùå Ocorreu um erro durante o processamento: {e}")
        st.warning("Verifique se ambos os arquivos s√£o CSVs v√°lidos e se a coluna 'CodigoPontoOohFiliado' existe em ambos. Detalhes: " + str(e))